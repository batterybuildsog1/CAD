## CAD3D Experimental Subtree

This directory contains an **experimental 3D CAD model and viewer layer** that
is intentionally kept separate from the current workspace UI and circulation
logic. Think of it as a "feature branch in the filesystem".

### Goals

- Represent a **full 3D house model**, not just rooms:
  - Rooms, walls, slabs, roofs
  - Studs, plates, sheathing, windows, doors
  - Plumbing / electrical / mechanical elements (future)
- Provide **stable, AI-friendly IDs** for every component so Gemini can:
  - Refer to `room:GF-Bedroom-1` or `stud:GF-Bedroom-1:W2:S13` unambiguously
  - Query and modify components via tools without guessing from geometry alone
- Support **SketchUp/Revit-style workflows**:
  - All major elements are 3D
  - Paint is treated as a colored surface over materials
  - Components are selectable and movable with constraints (future)

### Files

- `model.ts`
  - Core type definitions for the 3D CAD model:
    - `ComponentId`, `ElementKind`, `CadElement`
    - Specialized elements: rooms, walls, studs, sheathing, windows, doors, MEP
    - `Cad3DModel` as a container for all elements in a project
  - Pure TypeScript only – no React / rendering here.
  - Also defines **spec registries** used for future performance modeling:
    - `MaterialSpec`: density, conductivity, vapor permeance, etc.
    - `WindowSpec`: U-value, SHGC, VT, air leakage, glazing build-up
    - `DoorSpec`: U-value, STC, fire rating
    - `WallAssemblySpec`, `RoofAssemblySpec`, `SlabAssemblySpec`: layered assemblies with R-values and climate hints
  - Each `WindowElement` / `DoorElement` can reference a spec via `specId`, so
    geometry and performance are linked but not duplicated.

- `state.ts`
  - Helpers for constructing and querying a `Cad3DModel`:
    - `createEmptyCadModel`
    - `addElement`, `updateElement`, `findElementsByKind`, etc.
  - Designed to be easy to replace with a more sophisticated store later
    (e.g., shared with WASM or persisted to disk).

- `conversion.ts`
  - Converts the LLM-friendly `ObservableState` (what Gemini sees as `llmState`)
    into a minimal but correct `Cad3DModel`:
    - One `RoomElement` per `floorplan.rooms[*]` using canonical `points`
    - An optional `FloorSlabElement` that bounds all rooms on the active level
  - Deliberately **does not fabricate geometry**: if `points` are missing, the
    room is skipped rather than drawn as a box.

- `demoScene.ts`
  - Creates a **small sample model** used by the CAD Lab page:
    - One level with a single rectangular room
    - A short run of studs on one wall
  - This is ONLY for experimentation and visual smoke tests.

- `CadLabCanvas.tsx`
  - Minimal React Three Fiber viewer for the CAD3D model:
    - Renders rooms as simple extruded boxes from their footprints
    - Renders studs as small 3D boxes at their transforms
  - No interaction yet (selection/gizmos will be added later).
  - Used by `app/cad-lab/page.tsx` to visualize either:
    - The last Gemini layout (via `llmState` → `Cad3DModel` conversion), or
    - A static demo model when no stored state is available.

### Integration Points (Future)

- **From current layout to CAD3D**
  - A future `conversion.ts` module will translate `ObservableState` rooms
    (`RoomSummary.points`) into `RoomElement`s in `Cad3DModel`.
  - This will allow us to take a 2D layout generated by Gemini and "grow"
    a full 3D model with walls, studs, and systems.

- **Gemini Visibility**
  - CAD3D will eventually expose:
    - Summaries: structural/MEP/room counts, key spans, path metrics.
    - Component tools: `get_component`, `modify_component`, `list_components`.
  - The intent is for Gemini and humans to see **the same components**:
    what you click in the CAD UI is what Gemini talks about in text.

### Safety / Isolation

- No existing routes or components import from `cad3d/` except the **CAD Lab**
  page (`app/cad-lab/page.tsx`), which is purely experimental.
- Circulation and pathfinding logic in `lib/` is **not** wired to this yet.
- It is safe to work here, run visual experiments, and later decide what to
  merge into the main UX after testing.


