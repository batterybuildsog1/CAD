/**
 * Circulation Utilities - Smart door placement and connectivity validation
 *
 * Auto-generates doors when rooms are placed adjacent to each other.
 * Validates connectivity via BFS from entry point.
 * Returns warnings (non-blocking) for Gemini feedback loop.
 */

import type { RoomSummary } from './wasm-store.svelte';

// ============================================================================
// Types
// ============================================================================

export interface RoomBounds {
  id: string;
  name: string;
  x: number;      // SW corner X
  y: number;      // SW corner Y
  width: number;  // East-West dimension
  depth: number;  // North-South dimension
  type: string;
}

export interface SharedWall {
  start: [number, number];
  end: [number, number];
  direction: 'north' | 'south' | 'east' | 'west';
  length: number;
}

export interface DoorPlacement {
  id: string;
  type: 'door' | 'cased_opening';
  room1: string;
  room2: string;
  position: [number, number];
  width: number;
  height: number;
  wallDirection: 'north' | 'south' | 'east' | 'west';
  autoGenerated: boolean;
}

export interface ConnectivityResult {
  isFullyConnected: boolean;
  reachableRooms: string[];
  orphanedRooms: RoomSummary[];
  entryRoom: RoomSummary | null;
  warnings: string[];
  suggestions: string[];
}

export interface CirculationWarning {
  type: 'invalid_connection' | 'orphaned_room' | 'no_entry';
  message: string;
  affectedRooms: string[];
  suggestion?: string;
}

// ============================================================================
// Constants
// ============================================================================

const ADJACENCY_TOLERANCE = 0.5; // feet
const DEFAULT_DOOR_WIDTH = 3.0;
const CLOSET_DOOR_WIDTH = 2.5;
const CASED_OPENING_WIDTH = 4.0;
const DEFAULT_DOOR_HEIGHT = 6.67; // 6'8"

// Room type categories
const PUBLIC_ROOMS = ['living', 'kitchen', 'dining', 'family', 'great_room', 'foyer', 'mudroom'];
const PRIVATE_ROOMS = ['bedroom', 'bathroom', 'closet'];
const CIRCULATION_ROOMS = ['hallway', 'foyer', 'stair', 'landing', 'circulation'];
const SERVICE_ROOMS = ['garage', 'laundry', 'utility', 'pantry'];
const ENTRY_ROOM_TYPES = ['foyer', 'mudroom', 'living', 'garage'];

// Room type pairs that should auto-connect with doors
const AUTO_CONNECT_PAIRS: [string, string][] = [
  ['bedroom', 'hallway'],
  ['bedroom', 'closet'],
  ['bedroom', 'bathroom'],  // ensuite
  ['bathroom', 'hallway'],
  ['closet', 'hallway'],
  ['hallway', 'hallway'],   // hallway segments
  ['hallway', 'living'],
  ['hallway', 'kitchen'],
  ['hallway', 'dining'],
  ['hallway', 'family'],
  ['hallway', 'great_room'],
  ['hallway', 'foyer'],
  ['hallway', 'mudroom'],
  ['hallway', 'laundry'],
  ['hallway', 'utility'],
  ['hallway', 'office'],
  ['hallway', 'pantry'],
  ['foyer', 'living'],
  ['foyer', 'dining'],
  ['mudroom', 'garage'],
  ['mudroom', 'laundry'],
  ['garage', 'utility'],
  ['kitchen', 'pantry'],
  ['kitchen', 'dining'],
  ['kitchen', 'laundry'],
];

// Room type pairs that get open cased openings (no door)
const OPEN_PLAN_PAIRS: [string, string][] = [
  ['living', 'kitchen'],
  ['living', 'dining'],
  ['kitchen', 'dining'],
  ['living', 'family'],
  ['living', 'great_room'],
  ['kitchen', 'family'],
  ['dining', 'family'],
];

// Invalid direct connections (warnings only)
const INVALID_CONNECTIONS: [string, string, string][] = [
  ['bedroom', 'bedroom', 'Consider adding hallway between bedrooms'],
  ['bathroom', 'kitchen', 'Bathroom should not open directly to kitchen'],
  ['bathroom', 'dining', 'Bathroom should not open directly to dining room'],
  ['bedroom', 'kitchen', 'Bedroom should access kitchen via common area'],
  ['garage', 'bedroom', 'Garage should not connect directly to bedroom'],
  ['garage', 'kitchen', 'Garage should connect via mudroom (fire safety)'],
];

// ============================================================================
// Core Functions
// ============================================================================

/**
 * Convert RoomSummary to RoomBounds for calculations
 */
export function roomToBounds(room: RoomSummary): RoomBounds {
  return {
    id: room.id,
    name: room.name,
    x: room.center[0] - room.dimensions.width / 2,
    y: room.center[1] - room.dimensions.depth / 2,
    width: room.dimensions.width,
    depth: room.dimensions.depth,
    type: room.type
  };
}

/**
 * Find shared wall between two rooms (if any)
 */
export function findSharedWall(room1: RoomBounds, room2: RoomBounds): SharedWall | null {
  const r1 = {
    left: room1.x,
    right: room1.x + room1.width,
    bottom: room1.y,
    top: room1.y + room1.depth
  };
  const r2 = {
    left: room2.x,
    right: room2.x + room2.width,
    bottom: room2.y,
    top: room2.y + room2.depth
  };

  // Check vertical alignment (rooms side-by-side East-West)
  const verticalOverlap = Math.min(r1.top, r2.top) - Math.max(r1.bottom, r2.bottom);
  if (verticalOverlap > ADJACENCY_TOLERANCE) {
    // Room1's east wall touches Room2's west wall
    if (Math.abs(r1.right - r2.left) < ADJACENCY_TOLERANCE) {
      return {
        start: [r1.right, Math.max(r1.bottom, r2.bottom)],
        end: [r1.right, Math.min(r1.top, r2.top)],
        direction: 'east',
        length: verticalOverlap
      };
    }
    // Room2's east wall touches Room1's west wall
    if (Math.abs(r2.right - r1.left) < ADJACENCY_TOLERANCE) {
      return {
        start: [r1.left, Math.max(r1.bottom, r2.bottom)],
        end: [r1.left, Math.min(r1.top, r2.top)],
        direction: 'west',
        length: verticalOverlap
      };
    }
  }

  // Check horizontal alignment (rooms stacked North-South)
  const horizontalOverlap = Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left);
  if (horizontalOverlap > ADJACENCY_TOLERANCE) {
    // Room1's north wall touches Room2's south wall
    if (Math.abs(r1.top - r2.bottom) < ADJACENCY_TOLERANCE) {
      return {
        start: [Math.max(r1.left, r2.left), r1.top],
        end: [Math.min(r1.right, r2.right), r1.top],
        direction: 'north',
        length: horizontalOverlap
      };
    }
    // Room2's north wall touches Room1's south wall
    if (Math.abs(r2.top - r1.bottom) < ADJACENCY_TOLERANCE) {
      return {
        start: [Math.max(r1.left, r2.left), r1.bottom],
        end: [Math.min(r1.right, r2.right), r1.bottom],
        direction: 'south',
        length: horizontalOverlap
      };
    }
  }

  return null;
}

/**
 * Calculate door position on shared wall (center by default)
 */
export function calculateDoorPosition(
  wall: SharedWall,
  doorWidth: number = DEFAULT_DOOR_WIDTH
): [number, number] | null {
  if (wall.length < doorWidth) {
    return null; // Wall too short for door
  }

  // Center of shared wall
  return [
    (wall.start[0] + wall.end[0]) / 2,
    (wall.start[1] + wall.end[1]) / 2
  ];
}

/**
 * Determine door width based on room types
 */
export function getDoorWidth(type1: string, type2: string): number {
  // Closets get narrower doors
  if (type1 === 'closet' || type2 === 'closet') {
    return CLOSET_DOOR_WIDTH;
  }
  // Open plan connections get wider cased openings
  if (isOpenPlanPair(type1, type2)) {
    return CASED_OPENING_WIDTH;
  }
  return DEFAULT_DOOR_WIDTH;
}

/**
 * Check if two room types should have an open cased opening
 */
function isOpenPlanPair(type1: string, type2: string): boolean {
  return OPEN_PLAN_PAIRS.some(
    ([a, b]) => (type1 === a && type2 === b) || (type1 === b && type2 === a)
  );
}

/**
 * Check if two room types should auto-connect
 */
export function shouldAutoConnect(type1: string, type2: string): boolean {
  // Open plan pairs auto-connect
  if (isOpenPlanPair(type1, type2)) return true;

  // Check explicit auto-connect pairs
  return AUTO_CONNECT_PAIRS.some(
    ([a, b]) => (type1 === a && type2 === b) || (type1 === b && type2 === a)
  );
}

/**
 * Check for invalid room connections (returns warning, not error)
 */
export function checkRoomTypeRules(type1: string, type2: string): CirculationWarning | null {
  for (const [a, b, message] of INVALID_CONNECTIONS) {
    if ((type1 === a && type2 === b) || (type1 === b && type2 === a)) {
      return {
        type: 'invalid_connection',
        message,
        affectedRooms: []  // Will be filled in by caller
      };
    }
  }
  return null;
}

/**
 * Find all rooms adjacent to a given room
 */
export function findAdjacentRooms(
  newRoom: RoomSummary,
  existingRooms: RoomSummary[]
): Array<{ room: RoomSummary; wall: SharedWall }> {
  const newBounds = roomToBounds(newRoom);
  const adjacent: Array<{ room: RoomSummary; wall: SharedWall }> = [];

  for (const room of existingRooms) {
    if (room.id === newRoom.id) continue;

    const existingBounds = roomToBounds(room);
    const wall = findSharedWall(newBounds, existingBounds);

    if (wall) {
      adjacent.push({ room, wall });
    }
  }

  return adjacent;
}

/**
 * Auto-generate doors for a newly placed room
 */
export function autoGenerateDoors(
  newRoom: RoomSummary,
  existingRooms: RoomSummary[],
  existingDoors: DoorPlacement[]
): { doors: DoorPlacement[]; warnings: CirculationWarning[] } {
  const doors: DoorPlacement[] = [];
  const warnings: CirculationWarning[] = [];
  const adjacentRooms = findAdjacentRooms(newRoom, existingRooms);

  for (const { room: adjacentRoom, wall } of adjacentRooms) {
    // Check if door already exists between these rooms
    const existingDoor = existingDoors.find(d =>
      (d.room1 === newRoom.id && d.room2 === adjacentRoom.id) ||
      (d.room1 === adjacentRoom.id && d.room2 === newRoom.id)
    );
    if (existingDoor) continue;

    // Check room type rules
    const ruleWarning = checkRoomTypeRules(newRoom.type, adjacentRoom.type);
    if (ruleWarning) {
      ruleWarning.affectedRooms = [newRoom.id, adjacentRoom.id];
      warnings.push(ruleWarning);
    }

    // Determine if we should auto-connect
    if (shouldAutoConnect(newRoom.type, adjacentRoom.type)) {
      const doorWidth = getDoorWidth(newRoom.type, adjacentRoom.type);
      const position = calculateDoorPosition(wall, doorWidth);

      if (position) {
        const isOpenPlan = isOpenPlanPair(newRoom.type, adjacentRoom.type);
        doors.push({
          id: crypto.randomUUID(),
          type: isOpenPlan ? 'cased_opening' : 'door',
          room1: newRoom.id,
          room2: adjacentRoom.id,
          position,
          width: doorWidth,
          height: DEFAULT_DOOR_HEIGHT,
          wallDirection: wall.direction,
          autoGenerated: true
        });
      }
    }
  }

  return { doors, warnings };
}

/**
 * Validate connectivity via BFS from entry point
 */
export function validateConnectivity(
  rooms: RoomSummary[],
  doors: DoorPlacement[]
): ConnectivityResult {
  const result: ConnectivityResult = {
    isFullyConnected: true,
    reachableRooms: [],
    orphanedRooms: [],
    entryRoom: null,
    warnings: [],
    suggestions: []
  };

  if (rooms.length === 0) {
    return result;
  }

  // Find entry room
  const entryRoom = rooms.find(r => ENTRY_ROOM_TYPES.includes(r.type)) || rooms[0];
  result.entryRoom = entryRoom;

  // Build adjacency graph from doors
  const graph = new Map<string, Set<string>>();
  rooms.forEach(r => graph.set(r.id, new Set()));

  for (const door of doors) {
    graph.get(door.room1)?.add(door.room2);
    graph.get(door.room2)?.add(door.room1);
  }

  // BFS from entry
  const visited = new Set<string>([entryRoom.id]);
  const queue = [entryRoom.id];

  while (queue.length > 0) {
    const current = queue.shift()!;
    for (const neighbor of graph.get(current) || new Set()) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  result.reachableRooms = Array.from(visited);

  // Find orphaned rooms
  const orphaned = rooms.filter(r => !visited.has(r.id));
  result.orphanedRooms = orphaned;
  result.isFullyConnected = orphaned.length === 0;

  // Generate warnings and suggestions for orphaned rooms
  for (const orphan of orphaned) {
    result.warnings.push(`${orphan.name} has no door connection (orphaned)`);

    // Find suggestion - which reachable room could it connect to?
    const orphanBounds = roomToBounds(orphan);
    for (const reachableId of visited) {
      const reachable = rooms.find(r => r.id === reachableId)!;
      const wall = findSharedWall(orphanBounds, roomToBounds(reachable));
      if (wall && wall.length >= DEFAULT_DOOR_WIDTH) {
        result.suggestions.push(`Add door from ${orphan.name} to ${reachable.name}`);
        break;
      }
    }
  }

  return result;
}

/**
 * Categorize room by zone for state display
 */
export function getRoomZone(type: string): 'public' | 'private' | 'circulation' | 'service' {
  if (PUBLIC_ROOMS.includes(type)) return 'public';
  if (PRIVATE_ROOMS.includes(type)) return 'private';
  if (CIRCULATION_ROOMS.includes(type)) return 'circulation';
  if (SERVICE_ROOMS.includes(type)) return 'service';
  return 'public'; // Default
}

/**
 * Get all rooms grouped by zone
 */
export function groupRoomsByZone(rooms: RoomSummary[]): {
  public: RoomSummary[];
  private: RoomSummary[];
  circulation: RoomSummary[];
  service: RoomSummary[];
} {
  return {
    public: rooms.filter(r => getRoomZone(r.type) === 'public'),
    private: rooms.filter(r => getRoomZone(r.type) === 'private'),
    circulation: rooms.filter(r => getRoomZone(r.type) === 'circulation'),
    service: rooms.filter(r => getRoomZone(r.type) === 'service')
  };
}
