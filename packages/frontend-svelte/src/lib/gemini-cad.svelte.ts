/**
 * Gemini CAD Client - Svelte 5 Runes Implementation
 *
 * Implements the hybrid architecture:
 * - Gemini API calls go through server proxy (API key secure)
 * - Tool execution happens locally via WASM (zero latency)
 * - Visual feedback loop for validation (2 iterations max)
 */

import type { Content } from '@google/genai';
import { wasmManager, type ObservableState, type OpeningSummary } from './wasm-store.svelte';
import type { WasmStore } from './wasm-loader';
import type { ToolCall, ToolName, Point2D, RoomType, FloorplanProgram } from './gemini-types';
import {
  buildGoalOrientedPrompt,
  buildProgramPrompt,
  parseSelfVerification,
  isGenerationSuccessful,
  DEFAULT_SUCCESS_CRITERIA,
  type SelfVerificationReport
} from './gemini-prompts';
import {
  captureWithLabels,
  parseVisualFeedback,
  getVisualValidationPrompt,
  getMaxIterations,
  estimateVisualFeedbackCost,
  type VisualFeedbackResponse,
  type CostEstimate
} from './visual-feedback';
import {
  autoGenerateDoors,
  validateConnectivity,
  groupRoomsByZone,
  findSharedWall,
  calculateDoorPosition,
  roomToBounds,
  analyzeLayoutForGuidance,
  checkBedroomToLivingConnection,
  type DoorPlacement,
  type CirculationWarning
} from './circulation-utils';
import type { CostEstimate as ConstructionCostEstimate, CostCategory, CostLineItem, MaterialType, LaborType, PricingUnit } from './cost-types';
import type { WasmStoreExtended } from './wasm-loader';

// ============================================================================
// Types
// ============================================================================

interface TokenUsage {
  promptTokens: number;
  responseTokens: number;
  totalTokens: number;
}

interface PendingQuestion {
  question: string;
  options?: string[];
  context?: string;
  thoughtSignature?: string;
}

interface FunctionCall {
  name: string;
  args: Record<string, unknown>;
}

interface ChatResponse {
  success: boolean;
  text?: string;
  functionCalls?: FunctionCall[];
  history?: Content[];
  error?: string;
  thinking?: string;
  usage?: TokenUsage;
}

export interface GenerationResult {
  success: boolean;
  text?: string;
  error?: string;
  toolsExecuted: number;
  visualIterations: number;
  costEstimate?: CostEstimate;
}

export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  thinking?: string;
  toolCalls?: ToolCall[];
}

// ============================================================================
// Gemini CAD Manager - Svelte 5 Runes
// ============================================================================

// Maximum conversation turns to keep in history (prevents unbounded growth)
const MAX_HISTORY_TURNS = 10;

class GeminiCADManager {
  // Reactive state using Svelte 5 runes
  #messages = $state<ChatMessage[]>([]);
  #loading = $state(false);
  #error = $state<string | null>(null);
  #history = $state<Content[]>([]);
  #pendingQuestion = $state<PendingQuestion | null>(null);
  #totalTokens = $state(0);
  #visualIterations = $state(0);

  // Canvas reference for visual feedback
  #canvasRef: HTMLCanvasElement | null = null;

  // Getters for reactive access
  get messages() { return this.#messages; }
  get loading() { return this.#loading; }
  get error() { return this.#error; }
  get history() { return this.#history; }
  get pendingQuestion() { return this.#pendingQuestion; }
  get totalTokens() { return this.#totalTokens; }
  get visualIterations() { return this.#visualIterations; }

  /**
   * Set canvas reference for visual feedback
   */
  setCanvas(canvas: HTMLCanvasElement | null): void {
    this.#canvasRef = canvas;
  }

  /**
   * Add a message to the chat
   */
  addMessage(message: ChatMessage): void {
    this.#messages = [...this.#messages, message];
  }

  /**
   * Clear all messages
   */
  clearMessages(): void {
    this.#messages = [];
    this.#history = [];
    this.#totalTokens = 0;
    this.#visualIterations = 0;
  }

  /**
   * Prune history to prevent unbounded conversation growth.
   * Keeps only the last MAX_HISTORY_TURNS conversation turns (user + model pairs).
   * Each turn = 2 Content entries (user message + model response).
   */
  private pruneHistory(): void {
    const maxEntries = MAX_HISTORY_TURNS * 2; // Each turn is user + model
    if (this.#history.length > maxEntries) {
      // Keep the most recent entries
      this.#history = this.#history.slice(-maxEntries);
      console.log(`[GeminiCAD] Pruned history to ${MAX_HISTORY_TURNS} turns (${this.#history.length} entries)`);
    }
  }

  // Store the current program for reference in subsequent messages
  #currentProgram: FloorplanProgram | null = null;

  // Current LLM provider (supports all 4 models)
  #provider = $state<'gemini' | 'claude-sonnet' | 'claude-opus' | 'grok'>('gemini');

  get provider() { return this.#provider; }

  setProvider(provider: 'gemini' | 'claude-sonnet' | 'claude-opus' | 'grok'): void {
    this.#provider = provider;
    console.log(`[GeminiCAD] Switched to provider: ${provider}`);
  }

  /**
   * Get provider display info
   */
  getProviderDisplayName(): string {
    const names = {
      'gemini': 'Gemini 3.0 Pro',
      'claude-sonnet': 'Claude Sonnet 4.5',
      'claude-opus': 'Claude Opus 4.5',
      'grok': 'Grok 4.1'
    };
    return names[this.#provider] || this.#provider;
  }

  /**
   * Set the current floorplan program (from intake form)
   */
  setProgram(program: FloorplanProgram): void {
    this.#currentProgram = program;
  }

  /**
   * Get the current program
   */
  get currentProgram() { return this.#currentProgram; }

  /**
   * Generate CAD from natural language prompt
   * @param prompt - User's message or instruction
   * @param successCriteria - Goals to achieve
   * @param program - Optional FloorplanProgram from intake form (used for initial generation)
   */
  async generate(
    prompt: string,
    successCriteria: string[] = DEFAULT_SUCCESS_CRITERIA,
    program?: FloorplanProgram
  ): Promise<GenerationResult> {
    this.#loading = true;
    this.#error = null;
    this.#visualIterations = 0;

    // Store program if provided
    if (program) {
      this.#currentProgram = program;
    }

    // Add user message
    this.addMessage({
      role: 'user',
      content: prompt,
      timestamp: new Date()
    });

    try {
      // Build prompt - use program-aware prompt if we have a program
      const fullPrompt = this.#currentProgram
        ? buildProgramPrompt(this.#currentProgram, prompt, successCriteria)
        : buildGoalOrientedPrompt(prompt, successCriteria);

      // Initial generation
      let result = await this.executeGenerationLoop(fullPrompt);

      // Visual feedback loop (max 2 iterations)
      if (this.#canvasRef && result.success) {
        for (let i = 0; i < getMaxIterations(); i++) {
          const feedback = await this.performVisualValidation();
          this.#visualIterations++;

          if (feedback.validated) {
            console.log('[GeminiCAD] Visual validation passed');
            break;
          }

          // Apply corrections
          if (feedback.corrections) {
            console.log('[GeminiCAD] Applying visual corrections:', feedback.corrections);
            result = await this.executeGenerationLoop(feedback.corrections);
          }
        }
      }

      const costEstimate = estimateVisualFeedbackCost(this.#visualIterations);

      return {
        success: result.success,
        text: result.text,
        toolsExecuted: result.toolsExecuted,
        visualIterations: this.#visualIterations,
        costEstimate
      };
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : 'Generation failed';
      this.#error = errorMsg;
      return {
        success: false,
        error: errorMsg,
        toolsExecuted: 0,
        visualIterations: this.#visualIterations
      };
    } finally {
      this.#loading = false;
    }
  }

  /**
   * Execute the main generation loop (prompt -> tools -> response)
   */
  private async executeGenerationLoop(prompt: string): Promise<{
    success: boolean;
    text?: string;
    toolsExecuted: number;
  }> {
    let toolsExecuted = 0;
    let currentPrompt = prompt;

    while (true) {
      // Call server API
      const response = await this.callServerAPI(currentPrompt);

      if (!response.success) {
        return { success: false, text: response.error, toolsExecuted };
      }

      // Update history
      if (response.history) {
        this.#history = response.history;
      }

      // Update token count
      if (response.usage) {
        this.#totalTokens += response.usage.totalTokens;
      }

      // Execute function calls if any
      if (response.functionCalls && response.functionCalls.length > 0) {
        const toolResults = await this.executeTools(response.functionCalls);
        toolsExecuted += toolResults.length;

        // Sync state from WASM after tool execution
        wasmManager.syncFromWasm();

        // Format tool results for next iteration
        currentPrompt = this.formatToolResults(toolResults);
        continue;
      }

      // No more function calls - generation complete
      if (response.text) {
        this.addMessage({
          role: 'assistant',
          content: response.text,
          timestamp: new Date(),
          thinking: response.thinking
        });
      }

      return {
        success: true,
        text: response.text,
        toolsExecuted
      };
    }
  }

  /**
   * Perform visual validation using Gemini vision
   */
  private async performVisualValidation(): Promise<VisualFeedbackResponse> {
    if (!this.#canvasRef) {
      return { validated: true, corrections: null, issues: [] };
    }

    try {
      // Capture screenshot with room labels
      const rooms = wasmManager.observableState.floorplan.rooms;
      const imageBase64 = await captureWithLabels(this.#canvasRef, rooms);

      // Send to Gemini for visual validation
      const response = await fetch('/api/ai/vision', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          image: imageBase64,
          prompt: getVisualValidationPrompt()
        })
      });

      if (!response.ok) {
        console.warn('[GeminiCAD] Visual validation API failed');
        return { validated: true, corrections: null, issues: [] };
      }

      const data = await response.json();
      return parseVisualFeedback(data.text || '');
    } catch (e) {
      console.error('[GeminiCAD] Visual validation error:', e);
      return { validated: true, corrections: null, issues: [] };
    }
  }

  /**
   * Call the server API for LLM chat (supports Gemini, Claude, Grok)
   */
  private async callServerAPI(prompt: string): Promise<ChatResponse> {
    // Prune history before each request to prevent unbounded growth
    this.pruneHistory();

    try {
      const response = await fetch('/api/ai/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: prompt,
          history: this.#history,
          stateForLLM: this.formatStateForLLM(),
          provider: this.#provider
        })
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      return await response.json();
    } catch (e) {
      return {
        success: false,
        error: e instanceof Error ? e.message : 'API call failed'
      };
    }
  }

  /**
   * Execute CAD tools via WASM
   */
  private async executeTools(calls: FunctionCall[]): Promise<Array<{
    name: string;
    result: unknown;
    success: boolean;
  }>> {
    const results: Array<{ name: string; result: unknown; success: boolean }> = [];
    const store = wasmManager.store;

    if (!store) {
      return calls.map(c => ({
        name: c.name,
        result: { error: 'WASM store not initialized' },
        success: false
      }));
    }

    for (const call of calls) {
      try {
        const result = await this.executeTool(store, call.name as ToolName, call.args);
        results.push({ name: call.name, result, success: true });

        // Track level IDs
        if (call.name === 'add_level' && typeof result === 'string') {
          wasmManager.addLevel(result);
        } else if (call.name === 'remove_level') {
          const levelId = call.args.level_id as string;
          wasmManager.removeLevel(levelId);
        }
      } catch (e) {
        results.push({
          name: call.name,
          result: { error: e instanceof Error ? e.message : 'Tool execution failed' },
          success: false
        });
      }
    }

    return results;
  }

  /**
   * Execute a single CAD tool - 5 collaborative tools
   */
  private async executeTool(
    store: WasmStore,
    toolName: ToolName,
    args: Record<string, unknown>
  ): Promise<unknown> {
    const s = store as unknown as Record<string, (...args: unknown[]) => unknown>;

    switch (toolName) {
      case 'create_room': {
        // Auto-initialize project/building/level if needed
        const levelId = await this.ensureLevelExists(s, args.floor as number || 0);

        // Create rectangular room from x, y, width, depth
        const x = args.x as number;
        const y = args.y as number;
        const width = args.width as number;
        const depth = args.depth as number;
        const points: Point2D[] = [
          [x, y],
          [x + width, y],
          [x + width, y + depth],
          [x, y + depth]
        ];

        const roomId = s.create_room(
          levelId,
          args.room_type,
          args.name,
          points
        ) as string;

        // Update observable state with new room
        const newRoom = {
          id: roomId,
          name: args.name as string,
          type: args.room_type as string,
          area: width * depth,
          center: [x + width / 2, y + depth / 2] as [number, number],
          dimensions: { width, depth }
        };

        // Get existing rooms and doors for auto-generation
        const existingRooms = wasmManager.observableState.floorplan.rooms;
        const existingDoors = (wasmManager.observableState.floorplan.openings || [])
          .filter(o => o.type === 'door' || o.type === 'cased_opening') as DoorPlacement[];

        // Auto-generate doors based on adjacency rules
        const { doors: autoDoors, warnings: doorWarnings } = autoGenerateDoors(
          newRoom,
          existingRooms,
          existingDoors
        );

        // Add room to state
        wasmManager.updateState(state => ({
          ...state,
          floorplan: {
            ...state.floorplan,
            rooms: [...state.floorplan.rooms, newRoom],
            openings: [
              ...(state.floorplan.openings || []),
              ...autoDoors.map(d => ({
                id: d.id,
                type: d.type,
                room1: d.room1,
                room2: d.room2,
                width: d.width,
                height: d.height,
                position: d.position,
                wallDirection: d.wallDirection,
                autoGenerated: d.autoGenerated
              } as OpeningSummary))
            ]
          }
        }));

        // Validate connectivity after adding room
        const allRooms = [...existingRooms, newRoom];
        const allDoors = [...existingDoors, ...autoDoors];
        const connectivity = validateConnectivity(allRooms, allDoors);

        // Collect all warnings
        const warnings: string[] = [
          ...doorWarnings.map(w => w.message),
          ...connectivity.warnings
        ];

        // Update constraint warnings in state
        wasmManager.updateState(state => ({
          ...state,
          constraints: {
            ...state.constraints,
            warnings
          }
        }));

        // Auto-derive footprint from all rooms
        this.deriveFootprintFromRooms();

        // Build response message
        const connectedNames = autoDoors.map(d => {
          const room = existingRooms.find(r => r.id === d.room2);
          return room?.name || d.room2;
        });

        let message = `Created ${args.name} (${width}'×${depth}')`;
        if (autoDoors.length > 0) {
          message += `. Auto-connected to: ${connectedNames.join(', ')}`;
        }
        if (warnings.length > 0) {
          message += `\n\nWarnings:\n${warnings.map(w => `! ${w}`).join('\n')}`;
        }
        if (connectivity.suggestions.length > 0) {
          message += `\n\nSuggestions:\n${connectivity.suggestions.map(s => `→ ${s}`).join('\n')}`;
        }

        return {
          room_id: roomId,
          auto_doors: autoDoors.length,
          warnings,
          suggestions: connectivity.suggestions,
          message
        };
      }

      case 'update_room': {
        const roomId = args.room_id as string;
        // For now, update in observable state (WASM update_room to be added)
        wasmManager.updateState(state => ({
          ...state,
          floorplan: {
            ...state.floorplan,
            rooms: state.floorplan.rooms.map(room => {
              if (room.id !== roomId) return room;
              const newWidth = (args.width as number) ?? room.dimensions.width;
              const newDepth = (args.depth as number) ?? room.dimensions.depth;
              const newX = (args.x as number) ?? (room.center[0] - room.dimensions.width / 2);
              const newY = (args.y as number) ?? (room.center[1] - room.dimensions.depth / 2);
              return {
                ...room,
                name: (args.name as string) ?? room.name,
                dimensions: { width: newWidth, depth: newDepth },
                center: [newX + newWidth / 2, newY + newDepth / 2] as [number, number],
                area: newWidth * newDepth
              };
            })
          }
        }));
        this.deriveFootprintFromRooms();
        return { success: true, message: `Updated room ${roomId}` };
      }

      case 'delete_room': {
        const roomId = args.room_id as string;
        const roomToDelete = wasmManager.observableState.floorplan.rooms.find(r => r.id === roomId);
        const roomName = roomToDelete?.name || roomId;

        // Remove room and any doors connected to it
        wasmManager.updateState(state => ({
          ...state,
          floorplan: {
            ...state.floorplan,
            rooms: state.floorplan.rooms.filter(r => r.id !== roomId),
            openings: (state.floorplan.openings || []).filter(o =>
              o.room1 !== roomId && o.room2 !== roomId
            )
          }
        }));

        // Re-validate connectivity
        const remainingRooms = wasmManager.observableState.floorplan.rooms;
        const remainingDoors = (wasmManager.observableState.floorplan.openings || [])
          .filter(o => o.type === 'door' || o.type === 'cased_opening') as DoorPlacement[];
        const connectivity = validateConnectivity(remainingRooms, remainingDoors);

        wasmManager.updateState(state => ({
          ...state,
          constraints: {
            ...state.constraints,
            warnings: connectivity.warnings
          }
        }));

        this.deriveFootprintFromRooms();

        let message = `Deleted ${roomName}`;
        if (connectivity.warnings.length > 0) {
          message += `\n\nWarnings:\n${connectivity.warnings.map(w => `! ${w}`).join('\n')}`;
        }

        return { success: true, message };
      }

      case 'add_opening': {
        // Store opening info for later rendering
        const openingType = args.opening_type as 'door' | 'window' | 'cased_opening';
        const opening: OpeningSummary = {
          id: crypto.randomUUID(),
          type: openingType,
          room1: args.room1_id as string,
          room2: args.room2_id as string | undefined,
          width: args.width as number,
          height: args.height as number
        };
        wasmManager.updateState(state => ({
          ...state,
          floorplan: {
            ...state.floorplan,
            openings: [...(state.floorplan.openings || []), opening]
          }
        }));
        return { success: true, message: `Added ${opening.type} (${opening.width}'×${opening.height}')` };
      }

      case 'ask_user': {
        // Return the question to be displayed to the user
        return {
          type: 'question',
          question: args.question as string,
          options: args.options as string[] | undefined,
          context: args.context as string | undefined
        };
      }

      // ========================================================================
      // Wall Management Tools
      // ========================================================================

      case 'create_wall': {
        const { start_x, start_y, end_x, end_y, height = 8, wall_type = 'interior_partition' } = args as {
          start_x: number;
          start_y: number;
          end_x: number;
          end_y: number;
          height?: number;
          wall_type?: string;
        };
        const levelId = await this.ensureLevelExists(s, 0);

        // Get or create wall assembly
        let assemblyId: string;
        if (typeof s.get_or_create_wall_assembly === 'function') {
          assemblyId = s.get_or_create_wall_assembly(wall_type) as string;
        } else {
          // Fallback: create assembly manually if helper doesn't exist
          assemblyId = `assembly_${wall_type}`;
        }

        // Create wall using WASM binding
        let wallId: string;
        if (typeof s.create_wall_coords === 'function') {
          wallId = s.create_wall_coords(levelId, start_x, start_y, end_x, end_y, height, assemblyId) as string;
        } else {
          // Fallback: generate wall ID if WASM function not available
          wallId = crypto.randomUUID();
          console.warn('[GeminiCAD] create_wall_coords not available in WASM, wall created in state only');
        }

        // Update observable state with new wall
        wasmManager.updateState(state => ({
          ...state,
          floorplan: {
            ...state.floorplan,
            walls: [...(state.floorplan.walls || []), {
              id: wallId,
              start: [start_x, start_y] as [number, number],
              end: [end_x, end_y] as [number, number],
              height,
              wallType: wall_type
            }]
          }
        }));

        wasmManager.syncFromWasm();

        return {
          success: true,
          wallId,
          message: `Created ${wall_type} wall from (${start_x}, ${start_y}) to (${end_x}, ${end_y})`
        };
      }

      case 'auto_generate_walls': {
        const levelId = await this.ensureLevelExists(s, 0);

        let result: { wallsCreated: number; decisions: Array<{ room1: string; room2: string; wallType: string }> };

        if (typeof s.auto_generate_walls === 'function') {
          result = s.auto_generate_walls(levelId) as typeof result;
        } else {
          // Fallback: implement basic auto-generation logic in JS
          const rooms = wasmManager.observableState.floorplan.rooms;
          const decisions: Array<{ room1: string; room2: string; wallType: string }> = [];

          // Privacy rooms that always get walls
          const privacyTypes = ['bedroom', 'bathroom', 'closet', 'office'];
          // Open concept rooms that share space
          const openTypes = ['kitchen', 'dining', 'living', 'family', 'great_room'];

          for (const room of rooms) {
            const needsWalls = privacyTypes.includes(room.type);
            if (needsWalls) {
              decisions.push({ room1: room.id, room2: 'exterior', wallType: 'full' });
            }
          }

          result = {
            wallsCreated: decisions.length,
            decisions
          };
          console.warn('[GeminiCAD] auto_generate_walls not available in WASM, using JS fallback');
        }

        wasmManager.syncFromWasm();

        return {
          success: true,
          wallsCreated: result.wallsCreated,
          decisions: result.decisions,
          message: `Auto-generated ${result.wallsCreated} walls based on room types`
        };
      }

      case 'set_room_openness': {
        const { room1_id, room2_id, wall_type } = args as {
          room1_id: string;
          room2_id: string;
          wall_type: 'full' | 'none' | 'half' | 'cased_opening';
        };

        let result: { success: boolean; previousType?: string };

        if (typeof s.set_wall_between_rooms === 'function') {
          result = s.set_wall_between_rooms(room1_id, room2_id, wall_type) as typeof result;
        } else {
          // Fallback: update state directly
          result = { success: true };
          console.warn('[GeminiCAD] set_wall_between_rooms not available in WASM, updating state directly');
        }

        // Update observable state with room openness info
        wasmManager.updateState(state => ({
          ...state,
          floorplan: {
            ...state.floorplan,
            roomConnections: [...(state.floorplan.roomConnections || []), {
              room1: room1_id,
              room2: room2_id,
              wallType: wall_type
            }]
          }
        }));

        wasmManager.syncFromWasm();

        return {
          success: true,
          result,
          message: `Set wall type between rooms to '${wall_type}'`
        };
      }

      case 'generate_framing': {
        const { wall_id } = args as { wall_id?: string };

        if (wall_id) {
          // Generate framing for specific wall
          let framingSummary: { studCount: number; headerCount: number };

          if (typeof s.generate_wall_framing === 'function') {
            framingSummary = s.generate_wall_framing(wall_id) as typeof framingSummary;
          } else {
            // Fallback: estimate framing based on wall length
            const walls = wasmManager.observableState.floorplan.walls || [];
            const wall = walls.find(w => w.id === wall_id);
            if (wall) {
              const length = Math.sqrt(
                Math.pow(wall.end[0] - wall.start[0], 2) +
                Math.pow(wall.end[1] - wall.start[1], 2)
              );
              // Studs every 16" (1.33 ft)
              framingSummary = {
                studCount: Math.ceil(length / 1.33) + 1,
                headerCount: 0
              };
            } else {
              framingSummary = { studCount: 0, headerCount: 0 };
            }
            console.warn('[GeminiCAD] generate_wall_framing not available in WASM, using JS estimation');
          }

          wasmManager.syncFromWasm();

          return {
            success: true,
            framingSummary,
            message: `Generated framing for wall ${wall_id}`
          };
        } else {
          // Generate framing for all walls
          const levelId = await this.ensureLevelExists(s, 0);
          let wallIds: string[] = [];

          if (typeof s.get_level_walls === 'function') {
            wallIds = s.get_level_walls(levelId) as string[];
          } else {
            // Fallback: get walls from observable state
            wallIds = (wasmManager.observableState.floorplan.walls || []).map(w => w.id);
          }

          const results: Array<{ wallId: string; studCount: number }> = [];

          for (const wid of wallIds) {
            if (typeof s.generate_wall_framing === 'function') {
              const framingResult = s.generate_wall_framing(wid) as { studCount: number };
              results.push({ wallId: wid, studCount: framingResult.studCount });
            } else {
              // Fallback estimation
              const walls = wasmManager.observableState.floorplan.walls || [];
              const wall = walls.find(w => w.id === wid);
              if (wall) {
                const length = Math.sqrt(
                  Math.pow(wall.end[0] - wall.start[0], 2) +
                  Math.pow(wall.end[1] - wall.start[1], 2)
                );
                results.push({ wallId: wid, studCount: Math.ceil(length / 1.33) + 1 });
              }
            }
          }

          wasmManager.syncFromWasm();

          return {
            success: true,
            wallsFramed: wallIds.length,
            results,
            message: `Generated framing for ${wallIds.length} walls`
          };
        }
      }

      // ========================================================================
      // Cost Estimation Tools
      // ========================================================================

      case 'generate_cost_estimate': {
        // Generate cost estimate for current level
        const levelId = wasmManager.levelIds[0];
        if (!levelId) {
          return { success: false, error: 'No level available' };
        }

        const extStore = store as unknown as WasmStoreExtended;
        if (!extStore.generate_cost_estimate) {
          return { success: false, error: 'Cost estimation not available in WASM module' };
        }

        try {
          const estimate = extStore.generate_cost_estimate(levelId);

          // Convert WASM snake_case to camelCase for frontend
          const convertedLineItems: CostLineItem[] = estimate.line_items.map(item => ({
            id: item.id,
            category: item.category as CostCategory,
            description: item.description,
            materialType: item.material_type as MaterialType | undefined,
            laborType: item.labor_type as LaborType | undefined,
            quantity: item.quantity,
            unit: item.unit as PricingUnit,
            unitPrice: item.unit_price,
            total: item.total,
            notes: item.notes
          }));

          const convertedEstimate: ConstructionCostEstimate = {
            id: estimate.id,
            levelId: estimate.level_id,
            lineItems: convertedLineItems,
            subtotals: estimate.subtotals as Record<CostCategory, number>,
            laborTotal: estimate.labor_total,
            materialTotal: estimate.material_total,
            grandTotal: estimate.grand_total,
            createdAt: estimate.created_at,
            notes: estimate.notes
          };

          // Update observable state with cost estimate
          wasmManager.updateState(state => ({
            ...state,
            costEstimate: convertedEstimate
          }));

          // Return summary for AI
          return {
            success: true,
            estimate: {
              grandTotal: convertedEstimate.grandTotal,
              materialTotal: convertedEstimate.materialTotal,
              laborTotal: convertedEstimate.laborTotal,
              lineItemCount: convertedEstimate.lineItems.length,
              categorySummary: Object.entries(convertedEstimate.subtotals)
                .filter(([_, v]) => v > 0)
                .map(([k, v]) => ({ category: k, subtotal: v }))
            },
            message: `Generated cost estimate: $${convertedEstimate.grandTotal.toLocaleString()} total (${convertedEstimate.lineItems.length} line items)`
          };
        } catch (e) {
          return { success: false, error: String(e) };
        }
      }

      case 'set_unit_price': {
        // Set a material price
        const { material_type, unit, price, description } = args as {
          material_type: string;
          unit: string;
          price: number;
          description?: string;
        };

        const extStore = store as unknown as WasmStoreExtended;
        if (!extStore.set_material_price) {
          return { success: false, error: 'Price setting not available in WASM module' };
        }

        try {
          extStore.set_material_price(material_type, unit, price);
          return {
            success: true,
            message: `Set ${material_type} price to $${price} ${unit}${description ? ` (${description})` : ''}`
          };
        } catch (e) {
          return { success: false, error: String(e) };
        }
      }

      case 'set_labor_rate': {
        // Set a labor rate
        const { labor_type, unit, rate, description } = args as {
          labor_type: string;
          unit: string;
          rate: number;
          description?: string;
        };

        const extStore = store as unknown as WasmStoreExtended;
        if (!extStore.set_labor_rate) {
          return { success: false, error: 'Rate setting not available in WASM module' };
        }

        try {
          extStore.set_labor_rate(labor_type, unit, rate);
          return {
            success: true,
            message: `Set ${labor_type} rate to $${rate} ${unit}${description ? ` (${description})` : ''}`
          };
        } catch (e) {
          return { success: false, error: String(e) };
        }
      }

      case 'get_cost_breakdown': {
        // Get detailed cost breakdown by category
        const estimate = wasmManager.observableState.costEstimate;
        if (!estimate) {
          return {
            success: false,
            error: 'No cost estimate available. Run generate_cost_estimate first.'
          };
        }

        const { category } = args as { category?: string };

        if (category) {
          // Return items for specific category
          const items = estimate.lineItems.filter(item => item.category === category);
          const subtotal = estimate.subtotals[category as CostCategory] || 0;

          return {
            success: true,
            category,
            subtotal,
            itemCount: items.length,
            items: items.map(i => ({
              description: i.description,
              quantity: i.quantity,
              unit: i.unit,
              unitPrice: i.unitPrice,
              total: i.total
            })),
            message: `${category}: $${subtotal.toLocaleString()} (${items.length} items)`
          };
        }

        // Return full breakdown
        const categoriesWithCosts = Object.entries(estimate.subtotals)
          .filter(([_, v]) => v > 0)
          .map(([k, v]) => ({ category: k, subtotal: v }));

        return {
          success: true,
          grandTotal: estimate.grandTotal,
          materialTotal: estimate.materialTotal,
          laborTotal: estimate.laborTotal,
          categories: categoriesWithCosts,
          message: `Total: $${estimate.grandTotal.toLocaleString()} | Materials: $${estimate.materialTotal.toLocaleString()} | Labor: $${estimate.laborTotal.toLocaleString()}`
        };
      }

      default:
        throw new Error(`Unknown tool: ${toolName}`);
    }
  }

  /**
   * Auto-create project/building/level if they don't exist
   */
  private levelIds: Map<number, string> = new Map();
  private projectId: string | null = null;
  private buildingId: string | null = null;

  private async ensureLevelExists(
    s: Record<string, (...args: unknown[]) => unknown>,
    floor: number
  ): Promise<string> {
    // Check if level already exists
    if (this.levelIds.has(floor)) {
      return this.levelIds.get(floor)!;
    }

    // Create project if needed
    if (!this.projectId) {
      this.projectId = s.create_project('New Project', 'imperial', 'US_IRC_2021') as string;
    }

    // Create building if needed
    if (!this.buildingId) {
      this.buildingId = s.add_building(this.projectId, 'Main Building') as string;
    }

    // Create level
    const elevation = floor * 9; // 9' floor-to-floor
    const levelName = floor === 0 ? 'Ground Floor' : `Floor ${floor + 1}`;
    const levelId = s.add_level(this.buildingId, levelName, elevation, 9) as string;
    this.levelIds.set(floor, levelId);
    wasmManager.addLevel(levelId);

    return levelId;
  }

  /**
   * Derive footprint from room bounding box and set it in WASM
   */
  private deriveFootprintFromRooms(): void {
    const rooms = wasmManager.observableState?.floorplan?.rooms;
    if (!rooms || rooms.length === 0) {
      wasmManager.setFootprint(0, 0);
      return;
    }

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const room of rooms) {
      const halfW = room.dimensions.width / 2;
      const halfD = room.dimensions.depth / 2;
      minX = Math.min(minX, room.center[0] - halfW);
      maxX = Math.max(maxX, room.center[0] + halfW);
      minY = Math.min(minY, room.center[1] - halfD);
      maxY = Math.max(maxY, room.center[1] + halfD);
    }

    const width = maxX - minX;
    const depth = maxY - minY;

    // Update JS state
    wasmManager.setFootprint(width, depth);

    // Also set in WASM store so render_level_combined can find it
    const store = wasmManager.store;
    if (store && this.levelIds.size > 0) {
      // Get first level ID (ground floor)
      const levelId = this.levelIds.get(0);
      if (levelId) {
        try {
          const s = store as unknown as Record<string, (...args: unknown[]) => unknown>;
          if (typeof s.set_level_footprint_rect === 'function') {
            s.set_level_footprint_rect(levelId, width, depth);
            console.log(`[GeminiCAD] Set WASM footprint: ${width}' × ${depth}' for level ${levelId}`);
          } else {
            console.error('[GeminiCAD] set_level_footprint_rect not available on WASM store');
          }
        } catch (e) {
          console.error('[GeminiCAD] Failed to set WASM footprint:', e);
        }
      }
    }
  }

  /**
   * Format tool results for Gemini
   */
  private formatToolResults(results: Array<{ name: string; result: unknown; success: boolean }>): string {
    const formatted = results.map(r => {
      if (r.success) {
        return `${r.name}: ${JSON.stringify(r.result)}`;
      }
      return `${r.name}: ERROR - ${JSON.stringify(r.result)}`;
    }).join('\n');

    return `Tool execution results:\n${formatted}\n\nCurrent state:\n${this.formatStateForLLM()}`;
  }

  /**
   * Format observable state for LLM context
   */
  private formatStateForLLM(): string {
    const state = wasmManager.observableState;
    const { footprint, floorplan, constraints } = state;

    let output = `=== BUILDING FOOTPRINT ===\n`;
    output += `Size: ${footprint.width.toFixed(0)}' × ${footprint.depth.toFixed(0)}'\n`;
    output += `Coordinates: (0,0) at SW corner, X→East, Y→North\n`;

    const usedArea = floorplan.rooms.reduce((sum, r) => sum + r.area, 0);
    const totalArea = footprint.width * footprint.depth;
    output += `Total area: ${Math.round(totalArea)} sq ft | Used: ${Math.round(usedArea)} sq ft\n\n`;

    // Group rooms by zone
    const zones = groupRoomsByZone(floorplan.rooms);

    output += `=== ROOMS BY ZONE ===\n`;
    if (zones.public.length > 0) {
      output += `PUBLIC: ${zones.public.map(r => r.name).join(', ')}\n`;
    }
    if (zones.private.length > 0) {
      output += `PRIVATE: ${zones.private.map(r => r.name).join(', ')}\n`;
    }
    if (zones.circulation.length > 0) {
      output += `CIRCULATION: ${zones.circulation.map(r => r.name).join(', ')}\n`;
    }
    if (zones.service.length > 0) {
      output += `SERVICE: ${zones.service.map(r => r.name).join(', ')}\n`;
    }

    // Room details
    if (floorplan.rooms.length > 0) {
      output += `\n=== ROOM DETAILS ===\n`;
      for (const room of floorplan.rooms) {
        const x = (room.center[0] - room.dimensions.width / 2).toFixed(0);
        const y = (room.center[1] - room.dimensions.depth / 2).toFixed(0);
        output += `${room.name} [${room.id.slice(0, 8)}]: ${room.dimensions.width}'×${room.dimensions.depth}' at (${x},${y}) - ${Math.round(room.area)} sqft\n`;
      }
    }

    // Door connections
    const doors = (floorplan.openings || []).filter(o =>
      o.type === 'door' || o.type === 'cased_opening'
    );
    if (doors.length > 0) {
      output += `\n=== DOOR CONNECTIONS ===\n`;
      for (const door of doors) {
        const room1 = floorplan.rooms.find(r => r.id === door.room1);
        const room2 = floorplan.rooms.find(r => r.id === door.room2);
        const doorType = door.type === 'cased_opening' ? 'opening' : 'door';
        const position = door.position
          ? ` at (${door.position[0].toFixed(1)}, ${door.position[1].toFixed(1)})`
          : '';
        output += `${room1?.name || door.room1} <-> ${room2?.name || door.room2 || 'exterior'} (${doorType} ${door.width}'${position})\n`;
      }
    }

    // Circulation warnings (critical for Gemini feedback)
    if (constraints.warnings.length > 0) {
      output += `\n=== CIRCULATION WARNINGS ===\n`;
      for (const warning of constraints.warnings) {
        output += `! ${warning}\n`;
      }
    }

    // Orphaned rooms detection
    const doorsSet = new Set<string>();
    for (const door of doors) {
      doorsSet.add(door.room1);
      if (door.room2) doorsSet.add(door.room2);
    }
    const orphanedRooms = floorplan.rooms.filter(r => !doorsSet.has(r.id));

    if (orphanedRooms.length > 0 && floorplan.rooms.length > 1) {
      output += `\n=== ORPHANED ROOMS (need doors) ===\n`;
      for (const room of orphanedRooms) {
        output += `- ${room.name} (${room.type})\n`;
      }
    }

    // Design guidance for proactive suggestions
    const guidance = analyzeLayoutForGuidance(floorplan.rooms, doors as DoorPlacement[]);
    if (guidance.missingElements.length > 0 || guidance.suggestedQuestions.length > 0) {
      output += `\n=== DESIGN GUIDANCE ===\n`;
      output += `Layout status: ${guidance.layoutQuality}\n`;
      if (guidance.missingElements.length > 0) {
        output += `Missing: ${guidance.missingElements.join(', ')}\n`;
      }
      if (guidance.suggestedQuestions.length > 0) {
        output += `Consider asking:\n`;
        for (const q of guidance.suggestedQuestions) {
          output += `→ ${q}\n`;
        }
      }
    }

    // Check for bedroom-to-living soft warning
    const bedroomLivingWarning = checkBedroomToLivingConnection(
      floorplan.rooms,
      doors as DoorPlacement[]
    );
    if (bedroomLivingWarning) {
      output += `\n=== SOFT WARNING ===\n`;
      output += `! ${bedroomLivingWarning.message}\n`;
      if (bedroomLivingWarning.suggestion) {
        output += `→ ${bedroomLivingWarning.suggestion}\n`;
      }
    }

    return output;
  }

  // ============================================================================
  // Geometry Helpers
  // ============================================================================

  private calculatePolygonArea(points: Point2D[]): number {
    let area = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
      const j = (i + 1) % n;
      area += points[i][0] * points[j][1];
      area -= points[j][0] * points[i][1];
    }
    return Math.abs(area) / 2;
  }

  private calculateCentroid(points: Point2D[]): [number, number] {
    let cx = 0, cy = 0;
    for (const [x, y] of points) {
      cx += x;
      cy += y;
    }
    return [cx / points.length, cy / points.length];
  }

  private calculateBoundingBox(points: Point2D[]): { width: number; depth: number } {
    const xs = points.map(p => p[0]);
    const ys = points.map(p => p[1]);
    return {
      width: Math.max(...xs) - Math.min(...xs),
      depth: Math.max(...ys) - Math.min(...ys)
    };
  }
}

// Export singleton instance
export const geminiCAD = new GeminiCADManager();
