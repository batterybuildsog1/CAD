/**
 * WASM Store Manager - Svelte 5 Runes Pattern
 * Single source of truth for all CAD state
 */

import { getWasmStore, resetWasmStore, type WasmStore, type WasmStoreExtended } from './wasm-loader';

/**
 * Observable state derived from WASM - this is what Gemini sees
 */
export interface ObservableState {
  floorplan: {
    rooms: RoomSummary[];
    walls: WallSummary[];
    openings: OpeningSummary[];
  };
  layout: {
    totalArea: number;
    boundingBox: { width: number; depth: number };
    roomAdjacencies: [string, string][];
    circulation: string[];
  };
  constraints: {
    satisfied: string[];
    violated: string[];
    warnings: string[];
  };
  footprint: {
    width: number;
    depth: number;
  };
}

export interface RoomSummary {
  id: string;
  name: string;
  type: string;
  area: number;
  center: [number, number];
  dimensions: { width: number; depth: number };
}

export interface WallSummary {
  id: string;
  start: [number, number];
  end: [number, number];
  thickness: number;
  height: number;
}

export interface OpeningSummary {
  id: string;
  type: 'door' | 'window' | 'cased_opening';
  room1: string;                              // First room ID
  room2?: string;                             // Second room ID (interior doors)
  width: number;
  height: number;
  position?: [number, number];                // Auto-calculated center point
  wallDirection?: 'north' | 'south' | 'east' | 'west';
  autoGenerated?: boolean;                    // True if auto-created by circulation logic
}

/**
 * Create empty observable state
 */
export function createEmptyState(): ObservableState {
  return {
    floorplan: {
      rooms: [],
      walls: [],
      openings: []
    },
    layout: {
      totalArea: 0,
      boundingBox: { width: 0, depth: 0 },
      roomAdjacencies: [],
      circulation: []
    },
    constraints: {
      satisfied: [],
      violated: [],
      warnings: []
    },
    footprint: {
      width: 0,
      depth: 0
    }
  };
}

/**
 * Derive observable state from WASM store
 * This is called after EVERY tool execution to ensure sync
 */
export function deriveObservableState(
  store: WasmStoreExtended,
  levelId: string
): ObservableState {
  // If WASM has get_observable_state, use it directly
  if (store.get_observable_state) {
    try {
      const wasmState = store.get_observable_state(levelId);
      if (wasmState) {
        return wasmState as ObservableState;
      }
    } catch (e) {
      console.warn('[deriveObservableState] WASM query failed, falling back to empty state:', e);
    }
  }

  // Fallback: return empty state (WASM query methods not yet implemented)
  return createEmptyState();
}

/**
 * Svelte 5 WASM Store Manager using Runes
 */
class WasmStoreManager {
  // Reactive state using Svelte 5 runes
  #store = $state<WasmStore | null>(null);
  #loading = $state(true);
  #error = $state<string | null>(null);
  #levelIds = $state<string[]>([]);
  #observableState = $state<ObservableState>(createEmptyState());
  #mutationCount = $state(0);

  // Getters for reactive access
  get store() { return this.#store; }
  get loading() { return this.#loading; }
  get error() { return this.#error; }
  get levelIds() { return this.#levelIds; }
  get observableState() { return this.#observableState; }
  get mutationCount() { return this.#mutationCount; }

  /**
   * Initialize WASM store
   */
  async init(): Promise<void> {
    if (this.#store) return;

    try {
      this.#store = await getWasmStore();
      this.#loading = false;
    } catch (e) {
      this.#error = e instanceof Error ? e.message : 'WASM load failed';
      this.#loading = false;
      throw e;
    }
  }

  /**
   * Reset to fresh state
   */
  async reset(): Promise<void> {
    this.#store = await resetWasmStore();
    this.#levelIds = [];
    this.#observableState = createEmptyState();
    this.#mutationCount = 0;
  }

  /**
   * Add a level ID
   */
  addLevel(levelId: string): void {
    if (!this.#levelIds.includes(levelId)) {
      this.#levelIds = [...this.#levelIds, levelId];
    }
  }

  /**
   * Remove a level ID and clear state
   */
  removeLevel(levelId: string): void {
    this.#levelIds = this.#levelIds.filter(id => id !== levelId);
    if (this.#levelIds.length === 0) {
      this.#observableState = createEmptyState();
    }
  }

  /**
   * Sync observable state from WASM - call after every tool execution
   */
  syncFromWasm(): void {
    if (!this.#store || this.#levelIds.length === 0) {
      this.#observableState = createEmptyState();
      return;
    }

    const extStore = this.#store as unknown as WasmStoreExtended;
    this.#observableState = deriveObservableState(extStore, this.#levelIds[0]);
    this.#mutationCount++;
  }

  /**
   * Update observable state directly (for manual updates before WASM query methods exist)
   */
  updateState(updater: (state: ObservableState) => ObservableState): void {
    this.#observableState = updater(this.#observableState);
    this.#mutationCount++;
  }

  /**
   * Set footprint dimensions
   */
  setFootprint(width: number, depth: number): void {
    this.#observableState = {
      ...this.#observableState,
      footprint: { width, depth }
    };
  }
}

// Export singleton instance
export const wasmManager = new WasmStoreManager();
