/**
 * WASM Store Manager - Svelte 5 Runes Pattern
 * Single source of truth for all CAD state
 */

import { getWasmStore, resetWasmStore, type WasmStore, type WasmStoreExtended } from './wasm-loader';

/**
 * Observable state derived from WASM - this is what Gemini sees
 */
export interface ObservableState {
  floorplan: {
    rooms: RoomSummary[];
    walls: WallSummary[];
    openings: OpeningSummary[];
    roomConnections?: RoomConnection[];  // Wall type overrides between rooms
  };
  layout: {
    totalArea: number;
    boundingBox: { width: number; depth: number };
    roomAdjacencies: [string, string][];
    circulation: string[];
  };
  constraints: {
    satisfied: string[];
    violated: string[];
    warnings: string[];
  };
  footprint: {
    width: number;
    depth: number;
  };
}

export interface RoomSummary {
  id: string;
  name: string;
  type: string;
  area: number;
  center: [number, number];
  dimensions: { width: number; depth: number };
}

export interface WallSummary {
  id: string;
  start: [number, number];
  end: [number, number];
  thickness?: number;
  height: number;
  wallType?: string;  // 'exterior_2x6' | 'interior_partition' etc.
}

export interface RoomConnection {
  room1: string;
  room2: string;
  wallType: 'full' | 'none' | 'half' | 'cased_opening';
}

export interface OpeningSummary {
  id: string;
  type: 'door' | 'window' | 'cased_opening';
  room1: string;                              // First room ID
  room2?: string;                             // Second room ID (interior doors)
  width: number;
  height: number;
  position?: [number, number];                // Auto-calculated center point
  wallDirection?: 'north' | 'south' | 'east' | 'west';
  autoGenerated?: boolean;                    // True if auto-created by circulation logic
}

/**
 * Create empty observable state
 */
export function createEmptyState(): ObservableState {
  return {
    floorplan: {
      rooms: [],
      walls: [],
      openings: []
    },
    layout: {
      totalArea: 0,
      boundingBox: { width: 0, depth: 0 },
      roomAdjacencies: [],
      circulation: []
    },
    constraints: {
      satisfied: [],
      violated: [],
      warnings: []
    },
    footprint: {
      width: 0,
      depth: 0
    }
  };
}

/**
 * Derive observable state from WASM store
 * This is called after EVERY tool execution to ensure sync
 */
export function deriveObservableState(
  store: WasmStoreExtended,
  levelId: string
): ObservableState {
  // If WASM has get_observable_state, use it directly
  if (store.get_observable_state) {
    try {
      const wasmState = store.get_observable_state(levelId) as Partial<ObservableState> | null | undefined;
      if (wasmState) {
        // Merge WASM-derived state with a fully-initialized default to ensure
        // all nested objects/arrays (floorplan, footprint, constraints, etc.)
        // are always defined. This prevents runtime undefined access in views
        // even if WASM returns a partial structure.
        const empty = createEmptyState();

        const mergedFloorplan = {
          ...empty.floorplan,
          ...(wasmState.floorplan ?? {}),
          rooms: wasmState.floorplan?.rooms ?? empty.floorplan.rooms,
          walls: wasmState.floorplan?.walls ?? empty.floorplan.walls,
          openings: wasmState.floorplan?.openings ?? empty.floorplan.openings
        };

        const mergedLayout = {
          ...empty.layout,
          ...(wasmState.layout ?? {}),
          roomAdjacencies: wasmState.layout?.roomAdjacencies ?? empty.layout.roomAdjacencies,
          circulation: wasmState.layout?.circulation ?? empty.layout.circulation
        };

        const mergedConstraints = {
          ...empty.constraints,
          ...(wasmState.constraints ?? {}),
          satisfied: wasmState.constraints?.satisfied ?? empty.constraints.satisfied,
          violated: wasmState.constraints?.violated ?? empty.constraints.violated,
          warnings: wasmState.constraints?.warnings ?? empty.constraints.warnings
        };

        const mergedFootprint = {
          ...empty.footprint,
          ...(wasmState.footprint ?? {})
        };

        return {
          ...empty,
          ...wasmState,
          floorplan: mergedFloorplan,
          layout: mergedLayout,
          constraints: mergedConstraints,
          footprint: mergedFootprint
        };
      }
    } catch (e) {
      console.warn('[deriveObservableState] WASM query failed, falling back to empty state:', e);
    }
  }

  // Fallback: return empty state (WASM query methods not yet implemented)
  return createEmptyState();
}

/**
 * Svelte 5 WASM Store Manager using Runes
 */
class WasmStoreManager {
  // Reactive state using Svelte 5 runes
  #store = $state<WasmStore | null>(null);
  #loading = $state(true);
  #error = $state<string | null>(null);
  #levelIds = $state<string[]>([]);
  #observableState = $state<ObservableState>(createEmptyState());
  #mutationCount = $state(0);

  // Getters for reactive access
  get store() { return this.#store; }
  get loading() { return this.#loading; }
  get error() { return this.#error; }
  get levelIds() { return this.#levelIds; }
  get observableState() { return this.#observableState; }
  get mutationCount() { return this.#mutationCount; }

  /**
   * Initialize WASM store
   */
  async init(): Promise<void> {
    if (this.#store) return;

    try {
      this.#store = await getWasmStore();
      this.#loading = false;
    } catch (e) {
      this.#error = e instanceof Error ? e.message : 'WASM load failed';
      this.#loading = false;
      throw e;
    }
  }

  /**
   * Reset to fresh state
   */
  async reset(): Promise<void> {
    this.#store = await resetWasmStore();
    this.#levelIds = [];
    this.#observableState = createEmptyState();
    this.#mutationCount = 0;
  }

  /**
   * Add a level ID
   */
  addLevel(levelId: string): void {
    if (!this.#levelIds.includes(levelId)) {
      this.#levelIds = [...this.#levelIds, levelId];
    }
  }

  /**
   * Remove a level ID and clear state
   */
  removeLevel(levelId: string): void {
    this.#levelIds = this.#levelIds.filter(id => id !== levelId);
    if (this.#levelIds.length === 0) {
      this.#observableState = createEmptyState();
    }
  }

  /**
   * Sync observable state from WASM - call after every tool execution
   */
  syncFromWasm(): void {
    if (!this.#store || this.#levelIds.length === 0) {
      this.#observableState = createEmptyState();
      return;
    }

    const extStore = this.#store as unknown as WasmStoreExtended;
    this.#observableState = deriveObservableState(extStore, this.#levelIds[0]);
    this.#mutationCount++;
  }

  /**
   * Update observable state directly (for manual updates before WASM query methods exist)
   */
  updateState(updater: (state: ObservableState) => ObservableState): void {
    this.#observableState = updater(this.#observableState);
    this.#mutationCount++;
  }

  /**
   * Set footprint dimensions
   */
  setFootprint(width: number, depth: number): void {
    this.#observableState = {
      ...this.#observableState,
      footprint: { width, depth }
    };
  }

  /**
   * Update a room's position (center point)
   * Used when user drags a room to a new location
   */
  updateRoomPosition(roomId: string, newCenter: [number, number]): void {
    this.#observableState = {
      ...this.#observableState,
      floorplan: {
        ...this.#observableState.floorplan,
        rooms: this.#observableState.floorplan.rooms.map(room => {
          if (room.id !== roomId) return room;
          return {
            ...room,
            center: newCenter
          };
        })
      }
    };
    this.#mutationCount++;
  }

  /**
   * Update a room's dimensions and optionally its position
   * Used when user resizes a room via handles
   */
  updateRoomDimensions(
    roomId: string,
    newCenter: [number, number],
    newDimensions: { width: number; depth: number }
  ): void {
    this.#observableState = {
      ...this.#observableState,
      floorplan: {
        ...this.#observableState.floorplan,
        rooms: this.#observableState.floorplan.rooms.map(room => {
          if (room.id !== roomId) return room;
          return {
            ...room,
            center: newCenter,
            dimensions: newDimensions,
            area: newDimensions.width * newDimensions.depth
          };
        })
      }
    };
    this.#mutationCount++;
  }

  /**
   * Remove auto-generated openings for a specific room
   * Called before regenerating doors after a room move
   */
  clearAutoOpeningsForRoom(roomId: string): void {
    this.#observableState = {
      ...this.#observableState,
      floorplan: {
        ...this.#observableState.floorplan,
        openings: this.#observableState.floorplan.openings.filter(opening =>
          !opening.autoGenerated || (opening.room1 !== roomId && opening.room2 !== roomId)
        )
      }
    };
  }

  /**
   * Add openings to the floorplan
   * Used after regenerating auto-doors
   */
  addOpenings(newOpenings: OpeningSummary[]): void {
    this.#observableState = {
      ...this.#observableState,
      floorplan: {
        ...this.#observableState.floorplan,
        openings: [...this.#observableState.floorplan.openings, ...newOpenings]
      }
    };
    this.#mutationCount++;
  }

  /**
   * Update circulation warnings
   */
  setCirculationWarnings(warnings: string[]): void {
    this.#observableState = {
      ...this.#observableState,
      constraints: {
        ...this.#observableState.constraints,
        warnings
      }
    };
  }

  /**
   * Get a room by ID
   */
  getRoom(roomId: string): RoomSummary | undefined {
    return this.#observableState.floorplan.rooms.find(r => r.id === roomId);
  }

  /**
   * Get all rooms except the specified one
   */
  getOtherRooms(roomId: string): RoomSummary[] {
    return this.#observableState.floorplan.rooms.filter(r => r.id !== roomId);
  }
}

// Export singleton instance
export const wasmManager = new WasmStoreManager();
